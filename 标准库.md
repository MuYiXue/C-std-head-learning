1. C语言的标准库一共分为两个部分,每一个部分使用一个头描述,之所以叫头,而不是头文件,因为C标准没有规定标准库的实现必须放在头文件中,有一些编译器将便准库的实现内置在编译器中.这样一来,编写C语言程序会得到很大的便利

2. 标准头主要由宏定义,类型定义,函数定义构成,当我们使用了标准头中的任何一个部分,那么我们都应该在文件开头将相应的头文件包含进来

3. 对标准库中使用的一些名字的限制:

   1. 包含了标准头文件的文件不可以以任何目的再次使用在该标准头文件中已经定义过的宏的名字,这个名字一旦有了某一个用途,就不允许从新具有其他的用途.
   2. 具有文件作用域的库名,尤其时类型名,也不可以在文件层次重定义.比如一个文件包含了stdio.h那么,由于size_t在该文件中已经被定义为一个类型,就不可以将其定义为人额和标识符

4. 一些隐藏的限制:

   1. 由一个下划线和一个大写字母开头.或者由两个下划线开头的标识符,属于标准库中保留的标识符,程序不允许以任何目的使用这些标识符
   2. 由一个下划线开头的标识符被保留,用于文件作用域内的标识符和标记,除非仅声明在函数内部,否则不应该使用这些标识符.
   3. 在标准库中,所有外部链接的标识符被保留,用于作为需要外部链接的标识符,特别是所有标准库中的名字都被保留,因此即使程序没有包含stdio.h我们也不应该定义一个printf函数.

5. 使用宏隐藏函数

   C程序员往往会使用宏来取代小的函数,这一点在标准库中也同样常见,C语言允许在

头中定义一个与库函数相同的宏,为了起到保护作用,还要求有是的函数存在,因此对于库的头,声明一个函数同时定义一个同名的宏并不少见.

```c
int isprint(int c);//这是位于ctype的函数定义
@define isprint(c) ((c)>=0x20&&(c)<=0x7e)//与函数定义同名的宏定义
```

通常情况下,因为预处理先对代码进行替换,所以,一般都是宏定义,但是在特殊情况下,比如我们需要尽可能缩短代码的大小,我们可以使用#undef命令来进行来删除宏定义,从未可以访问到真实的函数.即使isprint不是宏这样的作法也不会有任何的负面影响,,因为当提供的民资没有被定义时,#undef命令不会发生任何作用

6. 标准库描概述:
   <assert.h> 仅仅包含assert宏,我们可以在程序中插入这个宏,从而检查程序的状态,一旦检查失败,程序会终止.

   ```c
       #define assert(expression) (void)(                                                       \
               (!!(expression)) ||                                                              \
               (_wassert(_CRT_WIDE(#expression), _CRT_WIDE(__FILE__), (unsigned)(__LINE__)), 0) \
           )
   从源码看来,如果条件检查失败,如果是在调试模式下,会直接无法通过检查,之后会在屏幕上打印出错位置.
   ```

   <ctype.h>包含了用于字符分类和大小写转换的函数.

   ```c
   //比如说isalnum()函数,这个函数可以检查一个字符是否为字母或者数字,如果时的话,就为1否则为0.
   ```

   <errno.h>这个头文件包含了errno("error number"),errno是一个左值,可以在调用特定函数库中检测,来判断调用过程中是否有错误发生.

   <float.h>提供了用于描述浮点类型特性的宏,包括宏的范围和精度.

   <limits.h>提供了描述整数类型宏字符类型特性的宏,包括他们的最大值和最小值.

   <locale.h>本地化,提供了一些函数来帮助程序适应一个国家或者地区的特定的行为方式,这些与本地化相关的行为包括数的显示方式(包括哟弄个与小数点的字符),货币的格式(货币符号),字符集和日期和时间的表示形式.

   <math.h>数学计算,提供了大量用于数学计算的函数,包括三角函数,双曲函数,指数函数,对数函数,幂函数,相似取整函数还有绝对值运算函数,其中大部分函数使用一个double类型的实际参数并且返回一个double类型的值.

   <setjmp.h> 提供了setjmp函数还有longjmp函数,setjmp函数会标记程序中的一个位置,之后可以用longjmp返回被标记的位置,这些函数可以用来从一个函数跳转到另一个任然在活动中的函数中,绕过正常的函数返回机制,setjmp函数和longjmp函数用来处理程序执行过程中出现的巨大问题.

   <signal.h>信号处理,这个头文件提供了异常情况(信号)处理的函数,包括终端和运行时错误,signal函数可以设置一个函数,使系统在给定信号发生后自动调用该函数,raise函数用来产生一个信号.

   <stdarg.h>: 可变实际参数
   
   这个头文件提供给函数可以处理不定个数的参数的工具,就像printf函数还有scanf函数.
   
   <stddef.h>: 常用定义:
   
   提供了经常使用的类型和宏的定义
   
   <stdio.h>: 标准输入输出
   
   提供了大量用于输入输出的函数,包括对于顺序读写和随机读写文案金的操作.
   
   <stdlib.h>: 常用实用程序.
   
   包含了大量无法划归于其他头的函数,这些函数可以将字符串转换为数,产生伪随机值,执行内存管理任务,与操作系统通信,执行搜索,排序还有对多字节字符和字符串进行操作.
   
   <string.h>: 字符串处理
   
   提供了用于进行字符串操作的函数,包括赋值,拼接,比较,和搜索.
   
   <time.h>: 日期和时间
   
   提供了相应的函数来获取日期和时间,操控时间和以多种方式显示时间.
   
   
   
   ### stddef 常用定义
   
   ```c
   ptrdiff_t 当指针进行相减运算时,其结果的类型
   size_t 运算符sizeof的返回类型
   wchar_t 一种足够大的,可以用来表示所有支持的地区的所有字符的类型.
   ```
   
   ```c
   //demo
   #include <stdio.h>
   #include <stddef.h>
   
   //两个宽字符输入,之后打印,他们各自的大小,地址差值,内容.
   
   int main(){
       wchar_t line[2][100];
       ptrdiff_t diff;
       size_t size[2];
       wchar_t model[100];
       
       diff=line[1]-line[0];
       
       for(int i=0;i<2;i++){
           sprintf(model,"请输入字符串%d: ",i+1);
           printf("%s",model);
           gets_s(line[i],100);
           printf("字符数组%d的大小是%d,其内容物是: %s\n",i+1,size[i],line[i]);
       }
       printf("这两个字符串的地址的差值是: %d\n",diff);
       return 0;
   
   }
   ```
   
   stddef.h中还提供了两个宏,,一个是NULL用来表示空指针,另一个ofsetof需要两个参数: 类型(一个结构类型)和指定成员(结构的一个成员),offsetof宏会计算结构的起点到指定成员之间的字节数.
   
   ```c
   struct s{
       char a;
       int b[2];
       float c;
   }
   
   在这个例子中,offsetof(struct 	s,a)的值一定是0.C语言确保结构的地址和其第一个成员的地址相同.我们无法确定的说出b和c的偏移量是多少,一种可能是offsetof(struct s,b)的大小是1,因为a的长度是一个字节,offsetof(struct s,c)大小是5,假设整数是16位,但是一些编译器会在结构中留下一些,从而会影响到offsetof的值,例如对于a下面留下一个无效字节的编译器,bc的偏移量应该是2和6,这就是offsetof的优点,对于任何编译器,其都会返回一个正确的偏移量,这样我们可以编写一个移植性很好的程序.
   ```
   
   offsetof的用途有很多,比如当我们需要将结构的前两个成员写入文件,但是忽略成员c,我们不可以使用fwrite函数来写入文件sizeof(struct s)个字节,因为这回将整个结构写入文件,但是我们可以只写入offsetof(struct s,c)个字节.
   
   ```c
   #define _CRT_SECURE_NO_WARNINGS
   
   #include <stdio.h>
   #include <stddef.h>
   #include <stdlib.h>
   
   struct s {
   	char a;
   	int b[2];
   	float c;
   };
   
   int main() {
   
   	char name[L_tmpnam] = "";
   	tmpnam(name);
   	FILE* pf;
   	pf = fopen(name, "w+");
   	
   	char buffer[100];
   
   	struct s demo;
   	demo.a = 'a';
   	demo.b[0] = 10;
   	demo.b[1] = 10;
   	demo.c = 2.222;
   	fwrite(&demo, offsetof(struct s, c), 1, pf);
   	fclose(pf);
   
   	pf= pf = fopen(name, "r");
   	fread(buffer, offsetof(struct s, c), 1, pf);
   	fclose(pf);
   
   	printf("%s\n", name);
   	printf("%s\n", buffer);
      
   	system("pause");
   	return 0;
   
   }
   //这个程序还真的挺人性化,竟然会直接声称在appdata中的temp文件中.
   ```
   
   