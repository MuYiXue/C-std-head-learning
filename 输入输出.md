1. 流

   在C语言中,**术语流意味着任意输入的源**或者任意输出的目的地.许多小程序,都是通过一个流来获得全部的输入,并且通过另一个流写出全部的输出.

   一些大型的程序需要额外的流,这些流通常表示磁盘上的文件,但是可以与其他类型的设备关联,调制解调器,网络端口,打印机,光盘驱动等等,这里集中讨论磁盘上的文件,因为这一类文件通用并且容易理解(在应该说流的时候这里可能会偶尔使用属于文件)

   但是必须要注意的一点是: stdio.h中的许多函数不仅仅可以处理表示成文件的流,还可以处理其他的所有的形式的流.

2. 文件指针

   C语言中的流通过访问文件指针实现,这个指针具有file* (在stdio.h定义了file的类型),用文件指针表示的具有特定流具有标准化的名字,如果需要,我们可以声明一些额外的文件指针,例如除了标准流,如果程序还需要两个流,那么我们可以在程序中包含下列形式的声明:
   ```c
   FILE * fp1,fp2;
   ```

   虽然操作系统通常会限制在任意的某个时刻可以打开的流的数量,但是一个程序可以声明任意数量的file *类型变量.

3. 标准流和输入重定向

   <stdio.h>提供了3中标准流:

   | 文件指针 | 流       | 默认的含义 |
   | -------- | -------- | ---------- |
   | stdin    | 标准输入 | 键盘       |
   | stdout   | 标准输出 | 屏幕       |
   | stdder   | 标准错误 | 屏幕       |

   前面使用的printf,scanf,putchar,getchar(),getc(),putc(),gets,puts.都是通过stdin输入,而且使用stdout输出,默认情况下,stdin表示键盘,二stdout和stderr表示屏幕,然而某些操作系统允许通过所谓的重定向机制来改变这些默认的含义.

   例如在UNIX和DOS操作系统中可以迫使程序从文件中而不是从键盘中获得输入,方法是在字符<后添加文件的名字,这种方法称为输出重定向

   ```c
   //理解--个人
   程序如何咋cmd环境下运行,格式就是
   程序.ext(程序自身作为参数1) 参数2 参数...
   
   向这个方面联想,因为程序必须放在第一个位置,指定的程序之后,计算机读取的后边的参数才有意义.
       
   流就像一个河流,其方向为信息流动的方向,指向程序表示信息流入程序,从程序指出到其他的地方表示将程序的信息输出.
       
   在命令行中,程序位于最左侧,所以指向程序就是小于号,表示输入从定向,指离程序就是大于号,表示输出重定向.
       
   注意在命令行中,输入输出重定向不作为程序的参数存在.
   也就是:
   程序.ext(程序自身作为参数1)  <输入.txt  >输出.txt  参数2 参数3...
   //argc=4 ...
   ```

   输入重定向的问题就是,如果程序运行失常,我们需要知道程序结束之后打开文件后才会知道,所以我们选哟将错误信息写入到stderr中,这样可以保证stdout发生重定向后错误信息仍然会出现在屏幕上.

   ```c
   fprintf(stderr,"错误信息");
   fputs("错误信息",stderr);
   puts("错误信息",stderr);
   putc('Q',stderr);
   
   stdder是一个预定义的全局变量,指向标准错误流,其变量类型为: File *,是一个指向FILE类型结构体的一个指针.
   
   //FILE 结构体封装了与特定输入输出源(如终端,磁盘文件,网络连接)交互所需要的所有信息,包括但是不限于:
    
   //1. 文件描述符,,在Unix系统中,这是一个小的非负整数,是由类型为每一个打开的文件分配的唯一标识符,通过文件标识符,程序可以与操作系统进行操交互,例如读写,关闭,等系统调用,对于标准错误流,其对应的文件描述符通常是2,标准输入0,标准输出1.
       
   //2. 缓冲区,为了提高输入输出效率,标准io通常会在内存中为每一个打开的流维护一个缓冲区,待缓冲区满了或者满足特定条件(比如遇到换行符或者手动刷新),才会将信息一次写入到实际的输出设备,标准错误通常设置为无缓冲或者行缓冲的形式,从而保证可以实时输出.
       
   //3. 缓冲区状态,包括缓冲区当前大小,已使用空间,当前位置(指针)等等信息,用于跟踪缓冲区数据状态以及何时将缓冲区的文件输出到输出流.
       
   //4. 文件位置指示器,对于可以定位的流,比如常规文件,结构体中包含一个表示当前文件读写位置的成员,对于标准错误流,由于它通常不支持随机访问,这个信息可能不是很重要.
       
   //5. 错误指示器,记录流上最近发生的IO错误状态,当发生错误时,后续的io可能会收到这个错误只是的影响.
       
   //6. EOF指示器,标记是否已经达到文件尾(EOF),对于标准错误流,这个信息通常无关紧要,因为他通常用于实时输出错误信息,而不是处理有限长度的文件.
       
   //7. 其他控制和私有标志,可能还包括一些内部使用的控制标志,以及编译器或者运行环境私有的数据,用来支持各种高级功能和特定系统接口的兼容性.我感觉还应该包含这个指针的用途,毕竟fopen函数就可以指定一个文件指针用于什么操作.后面对file*进行读写时,直接使用指针,而fopen函数已经结束.
   
   ```

4. 文本文件和二进制文件

   stdio.h支持两种类型的文件: 文本文件和二进制文件,在文本文件中,字节表示字符,这使人们可以检查或者编辑文件,例如C语言的源码时存放在文本文件中的,但是在二进制文件中,字节不一定是字符,字节还可以是其他类型的数据,比如整数和浮点数.

   选择二进制通常会极大的节约空间

   为什么一定要区分文本文件和二进制文件?毕竟无论哪个形式,一个文件就是一个字节的序列,文本文件按照行来划分,所以必须使用一些方法来标记每行的末尾,比如采用特殊的字符,而且操作系统可能用特殊的字符啦说明文本文件的结束,但是二进制文件可以合法的包含任何字符,所以不可能留出文件结束字符.

   ```c
   //我有一个好想法,在文本文件中我们无法写入控制字符,但是我们可以在二进制文件中写入控制字符.
   ```

   在DOS操作系统中,文本文件和二进制文件存在两个方面的差异:

   1. 行的结尾,文本文件需要特殊的标记,但是在二进制文件中不需要(回车)
   2. 文件末尾,文本文件需要特殊的标记,但是在二进制文件中不需要(ctrl +Z)
   3. 包含的特殊字符,文本文件只可以打印非控制字符,但是二进制文件可以存放一切字符,这意味着我们需要拷贝程序时,最好使用二进制,在不知道该如何处理时,最好也使用二进制.

5. 文件操作

   简单时输入输出重定向的魅力所在,他不需要打开文件,关闭文件或者执行其他明确的文件操作,但是重定向在许多程序中受到限制,当程序以来重定向时,他无法控制自己的文件,甚至无法知道这些文件的名字,更糟糕的是,如果程序需要咋同一个时间读入两个文件或者写入两个文件,重定向都无法做到

   ```c
   //所以一个支持重定向功能的程序应该具有以下特征:
   1. 错误信息使用标准错误流实时输出,而不是被重定向到生成文件中
   2. 程序只具有单个输入和单个输出
   ```

   1. 打开文件:

      ```c
      FILE * fopen(const char *filename,const char *mode);
      ```

      使用流的方式打开文件需要调用fopen函数,fopen的第一个实际参数就是要打开的文件的自负串,(需要注意的是,这个文件名可以包含关于文件位置信息,例如驱动器号或者路径)第二个实际参数就是模式,比如"r"表示打开.

      ---

      dos程序员,在遇到字符\时需要小心,因为C语言会将\看成转义序列的开始,从而导致程序无法正常运行,解决的办法就是使用\\\或者 /来替换\

      ```c
      //对于学习计算机的人而言,我们如何区分除法和转义序列?其实只需要记住其在键盘上的位置就可以了,辅助记忆: 除法左/右,其实就是分式横杠向左偏移.的产物.
      ```

      ---

      模式,打算传递给fopen的模式字符串不仅仅依赖于稍后要对文件采取的操作内容,还取决于文件上的数据是文本形式还是二进制形式.

      | 字符串     | 含义                                                   |
      | ---------- | ------------------------------------------------------ |
      | "r"(read)  | 打开的文件用于读                                       |
      | "w"(write) | 打开的文件用于写                      (文件无需存在)   |
      | "a"(add)   | 打开的文件用于追加                  (文件无需存在)     |
      | "r+"       | 打开的文件用于读和写                                   |
      | "w+"       | 打开的文件用于读和写              (如果文件存在就截去) |
      | "a+"       | 打开的文件用于读和写              (如果文件存在就追加) |

      这里需要说明,截去,指的是将文件长度截去为0,也就是从文件头开始写,后面的内容如果没有写到就不改变.

      ```c
      //小规律:
      1. 单个字母,用途就是本身    要么读要么写,
      2. 字母添加了一个+号       既可读也可写
      3. +表示补全其不具有的功能,但是原来的功能不变.
      
      比如"w+"表示的就是在w的基础上添加读取文件的能力,但是写的能力没有变,也就是如果文件存在就截断文件长度为0,从文件头开始写入,如果文件不存在就自行创建一个,从文件头写入.
      
      "r+"表示的就是在r的基础上添加写入文件的能力,但是读的能力没有改变,也就是始终从文件头开始.
      ```

      如果我们需要使用fopen打开二进制文件时,需要在模式字符串中包含字母b

      | 字符串      | 含义                                                   |
      | ----------- | ------------------------------------------------------ |
      | "rb"(read)  | 打开的文件用于读                                       |
      | "wb"(write) | 打开的文件用于写                      (文件无需存在)   |
      | "ab"(add)   | 打开的文件用于追加                  (文件无需存在)     |
      | "r+b"       | 打开的文件用于读和写                                   |
      | "w+b"       | 打开的文件用于读和写              (如果文件存在就截去) |
      | "a+b"       | 打开的文件用于读和写              (如果文件存在就追加) |

      stdio对写入数据和追加数据做了区分,当给文件写数据时,通常会对先前的内容进行覆写,然而当为追加文件时,试图为文件写入数据实际是在文件的末尾进行添加,二会留存原始数据的内容.

      顺便说一下,应用于既读又写一个已打开文件时的特殊规则(模式字符串包含+),如果没有先调用文件定位函数,那么就不可以将读转为写,而且如果既没有调用fflush函数,也没有调用文件定位函数,那么就不可以将写转换为读.

      1. 关闭文件


      ```c
      int fclose(FILE * stream);
      ```
    
      fclose函数允许程序关闭不再使用的文件,fclose函数的实际参数必须时文件指针,这个指针来自于fopen或者freopen的调用,如果成功关闭了文件,那么fclose函数会返回0,否则会返回错误代码EOF(在stdio.h中定义的宏)
    
      ```c
      #define _CRT_SECURE_NO_WARNINGS
      
      #include <stdio.h>
      #include <stdlib.h>
      
      #define FILE_NAME "example.dat"
      
      int main() {
      	FILE* fp;
      	fp = fopen(FILE_NAME, "r");
      	if (fp == NULL) {
      		fprintf(stderr, "文件无法打开\n");
      		exit(EXIT_FAILURE);
      	}
      	fclose(fp);
      	return 0;
      }
      //这里需要提示的就是,最好将指针写为fp,表示file_pointer,而不是像别人通常写的pf,point_to_file的缩写,这实际上是命名体会混乱的体现.
      
      //C语言中,只有函数应该包含动词,或者宏定义实现的"伪函数"可以用动词,其余的东西都应该使用名词,这是最通用的行业共识.
      ```
    
      1. 为流附加文件:


      ```c
      FILE* freopen(const char *filename,const char *mode,FILE *stream)
      ```
    
      freopen函数可以为已经打开的流附加上一个不同的文件,,freopen函数的最常见的用法就是将文件和其中的一个标准流向关联,这些标准流包括,stdin,stdout,stderr,例如,为了使程序开始向文件foo写入数据,可以使用下列形式的freopen调用:
    
      ```c
      if(freopen("foo","w",stdout)=NULL){
      /*error;foo can't be opened*/
      }
      ```
    
      在关闭了任何先前于stdout相关联的文件之后,(通过命令行重定向或者前一个freopen函数调用),freopen函数将打开文件foo,并且是这个文件和stdout相关联.
    
      freopen的返回值是他的第三个参数--文件指针,通常是自己,但是如果无法打开文件,将返回一个空指针.(如果无法关闭旧的文件,那么freopen将忽略错误.)
    
      1. ```c
         //小总结:
         stdio.h到底为文件流提供了怎样的操作呢?我大致将其分为三类:
         1. 一些预先定义好的流,比如说标准输入,标准输出,标准错误,分贝对应了FILE 结构体重的文件描述符 0,1,2
             
         2. 允许用户自己定义流的函数fopen,可以通过这个函数创建一个自定义流
             
         3. 关闭流的工具 fclose,可以用来关闭来自fopen或者freopen的指针.
             //多嘴一句: stdin,stderr,和stderr是由操作系统在程序启动时自动打开并且关联到相应的设备的特殊的流.根据C标准,对于stdin,stdout,和stderr使用fclose 的行为没有明确规定其效果,实际上,不同的编译器和平台可能对此由不同的实现和处理,一些平台会允许关闭这些流,但是后果可能包括但是不限于:引发异常,设置错误标志
             //实际测试表示,就MS的编译器而言,可以关掉!!!如何体现?
             //1. fclose 的返回值是0而不是EOF
             //2. fclose 后的scanf无法运行
             //但是没有引发十分严重的问题,额我指的是程序没有崩溃,只不过是无法输入了罢了.
             
         4. 重定向流的工具 freopen
             //这个工具的使用场景就是程序内部的重定向.日志记录,调试,还有在算法竞赛处理多个测试数据集等.
             //注意这个工具的局限性: freopen在处理任何已经打开的流,包括标准输入流,都会遵循先关闭之后重新打开的原则
             //如果希望在重定向标准输入流后让恢复原来的值,可以如此做:
         #ifdef win32
             Windows:freopn("CON","r",stdin);
         #else
         	Linux:freopen("/dev/tty","r",stdin);
         #endif
         ```


      合在一块说就是: 提供了一些预定义流,允许自定义流,允许自己打开或者关闭流,允许重新设置流的指向.
    
      1. 临时文件:


      ```c
      FILE* tmpfile(void);
      char *tmpnam(char *s);
      ```
    
      现实世界的程序经常需要产生临时文件,即只在程序运行时存在的文件,例如C语言编译器就常常产生临时文件,stdio.h提供了两种方法处理临时文件,即tmpfile函数,和tmpnam函数,这两个函数一个直接创建临时文件,一个创建一个临时文件的名字.
    
      tmpfile不需要任何参数,但是其会返回一个文件指针,这个指针指向生成的临时文件,如果临时文件产生失败,就会返回一个空指针.虽然tmpfile使用起来十分简单,但是,有两个缺点,这个文件的文件名对于用户而言是不知道的,无法决定这个临时文件是否要保留.如果我们想要了解到这些文件的名字,可以生成随机的一个名字,之后使用fopen来手动创建临时文件.
    
      而生成这个随机名称的函数就是tmpnam,如果这个函数的实参是一个空指针,那么会分配一个静态变量用来存放名字,之后将这个静态变量的地址作为返回值,如果这个函数的实参指向一个数组,必须确保这个数组具有足够的字节,否则会由内存泄露的情况出现
    
      ```c
      //demo--两种用法.
      char *tmp_name;
      tmp_name=tmpnam(NULL);
      fp=fopen(tmp_name,"w");
      free(tmp_name);


​      
​      char tmp_name[L_tmpnam];
​      tmpnam(tmp_name);
​      fp=fopen(tmp_name,"w");
​      //这两种写法都可以.而在最后一种情况下,L_tmpnam是一个定义在stdio.h中的宏,用来指明生成的名字的最大长度.
​      
      //关于这个tmpnam函数还有一些发现,实际操作,在MS编译器下,随机文件生成在temp的系统文件夹下.因为生成的文件名含有temp文件夹的完整路径.
      
      //最后依然是小总结:生成临时文件一共有两种方式,一个是直接创建文件,隐藏名字,另一种是在随机文件所在文件夹中生成一个具有随机名字的文件.
      ```
    
      1. 文件缓冲


      ```c
      int fflush(FILE *stream);
      void setbuf(FILE *stream,char *buf);
      int setvbuf(FILE *stream,char *buf,int type,size_t size);
      ```
    
      从磁盘驱动器或者传入信息是比较慢的操作,这样的结果是程序每次想要读或者写字 符时无法直接访问磁盘文件进行,这样的,获得有效性能的诀窍就是缓冲(buffering):写入流的数据实际存储在内存的缓冲区内,当缓冲区满了(或者关闭流)时,缓冲区会清洗(写入实际的输出设备).
    
      输入流可以使用类似的方法进行缓冲:缓冲区包含来自输入设备的数据.从缓冲区读取数据代替了从设备本身读取数据,缓冲在效率上可以取得巨大的收益,因为在缓冲区读取字符或者在缓冲区写入字符几乎不花时间,
    
      大多数时候stdio.h中的函数会自动完成缓冲操作,缓冲发生在屏幕后台,而且通常不需要考虑他的操作,但是有时我们需要承担一些更加主动的作用,如果真的如此,可以使用fflush函数,setbuf函数还有setvbuf函数.
    
      当程序向文件中写入程序时,数据通常时放在缓冲区中而不是文件内部,当缓冲区满了或者关闭文件时,缓冲区会自然清洗,然而通过调用fflush函数,程序可以像希望的那样频繁的清洗文件的缓冲区.
    
      ```c
      fflush(fp)//会清空fflush的缓冲区
      fflush(NULL)//会清空所有的输出流,如果成功会返回0,如果失败就返回EOF
      ```
    
      setvbuf函数允许改变缓冲流的方法,并且控制缓冲区的大小和位置,函数的**第三个实际参数**说明了期望的缓冲区的类型: 
    
      1. _IOFBF(满缓冲),当缓冲区为0时,从流读取数据,或者当缓冲区满时,向流写写入数据
      2. _IOLBF(行缓冲),每次从流读入一行数据或者向流写入一行数据.
      3. _IONBF(无缓冲),直接从流读入数据,或者直接向流写入数据,而没有缓冲区.
    
      setvbuf函数在第二个参数(如果不是空指针的话),是期望的缓冲区的类型,缓冲区可以有静态存储期限,自动存储期限或者可以是动态分配的,使缓冲区自动化将允许他的空间在块退出时可以被自动重声明,动态分配的缓冲区可以在不需要时自动释放,setbuf的最后一个实际参数时缓冲区中的字节的数量,较大的缓冲区可以提供更好的性能,而较小的缓冲区可以节约空间.
    
      ```c
      //小总结:
      setvbuf(FILE *stream,char *buf,int type,size_t size);
      先指明流的名称,其缓冲区的位置,缓冲区类型,缓冲区大小,还是相当符合逻辑的.
      ```
    
      如果这个函数调用成功,那么函数会返回0,否则会返回一个非0值
    
      setbuf是一个早期的函数,它用来设定缓冲区的默认值和缓冲区的大小,如果buf是空指针,那么setbuf(stream,buf)的调用你就等价于
    
      ```c
      (void) setvbuf(strean,NULL,_IONBF,0);
      ```
    
      否则的话,就等价于
    
      (void)setvbuf(stream,buf,_IOFBUF,BUFSIZ);这里的BUFSIZ是在<stdio.h>zhogn1中定义的宏我们将setbuf看作是陈旧的内容,不建议大家在新的程序中使用.
    
      ```c
      //需要注意的点:
      1. 当使用setvbuf函数或者setbuf函数时,一定要确保在释放缓冲区之前就已经关闭了流.
      2. 必须在打开stream之后,而且执行任何其他在stream上的操作之前调用setvbuf函数.
      也就是必须确保,在stream打开后,没有关闭前都要保持缓冲区的存在.千万注意释放和清空是不一样的,释放指的是取消一块内存,而不是清空这块内存上的所有内容.
      ```
    
      1. 其他文件操作:
    
      ```c
      int remove(const char *filename);
      int rename(const char *old,const char *new);
      ```
    
      remove 和rename可以为程序执行提供基本的文件管理工作,不同于这一节中大多数函数,这两个函数,对文件名而不是文件指针进行处理,如果调用成功,两个函数都返回0否则都返回非0值.
    
      ```c
      remove("filename");//删除文件
      rename("old name","new name");
      ```
    
      如果我们决定将文件变为永久的,那么rename是很便于对用fopen函数产生的临时文件进行换名,如果具有新的名字的文件已经存在了,那么效果将根据实现来定义.
    
      ```c
      需要注意的是,如果打开了要换名的文件,那么一定要确保在调用之前,这个文件是关闭的,否则这个文件无法被重命名.
      ```
    
      ```c
      //这是一个针对文件操作的大demo程序实例
      #define _CRT_SECURE_NO_WARNINGS
      
      #include <stdio.h>
      #include <stdlib.h>
      
      #define BUFFER_LEN 512
      
      int main() {
      	/*分析:我们的目的是通过随机名字创\
      	建一个随机文件,所以需要有名字,文件\
      	指针,还有缓冲区*/
      	char* filename;
      	FILE* fp;
      	char* buffer;
      
      	filename = tmpnam(NULL);
      	fp = fopen(filename, "w");
      	buffer = malloc(sizeof(char) * BUFFER_LEN);
      
      	setvbuf(fp, buffer, _IOFBF, BUFFER_LEN);//缓冲区设置好了.
      	fprintf(fp, "%d\n", 1887415157);
      	fprintf(fp, "%s\n", "你是螺旋升天大傻逼,真的");
      	fflush(fp);//清空我们自定义流的缓冲区
      	freopen("CON", "r", fp);//将文件流重定向到标准输入,这个过程会先关闭旧的流
      	free(buffer);//当文件流关闭后可以直接去除缓冲区.


​      
​      	char choose;
​      	printf("你想要保存程序产生的文件吗(Y/N): ");
​      	fscanf(fp, "%c", &choose);
​      	if (choose == 'Y' || choose == 'y') {
​      		if (rename(filename, "程序生成的文件") == 0) {
​      			printf("文件生成成功!\n");
​      			remove(filename);//删除临时文件
​      		}
​      		else {
​      			fprintf(stderr, "文件生成失败!\n\
​      临时文件名: %s\n""请自行到指定位置查看!\n", filename);
​      		}
​      	}else {
​      		fprintf(stderr, "你没有选择生成文件\n\
​      临时文件名: %s\n""请自行到指定位置查看!\n", filename);
​      	}
​      
      	return 0;
      }
      //有了动态分配内存后,感觉有一点离不开他了,真的回不去了,呜呜呜~~~
      ```
    
      1. 格式化输入输出
    
         1. ...printf类函数


         ```c
         int fprintf(FILE *stream,const char* format,...);
         int printf(const char *format,...);
         ```
       
         fprintf和printf可以为输出流写可变的数据项,并且利用格式串来控制输出的形式,这两个函数的返回值都是以省略号结尾的,省略号说明额外的实际参数的可变数量,这两个函数的返回值是写入的字符数,如果出错就返回一个负值.
       
         printf函数的调用相当于将fprintf第一个参数设置为stdout的调用.
       
         在stdout中还有其他的两种函数也可以向流写入格式化的输出:
       
         vfprintf,vprintf.这两个函数将在后面的stdarg中提到.
       
         1. ...printf类函数的转换说明.


         fprintf函数和printf函数都要求格式串包含普通字符或者转换说明,普通字符会原样输出,而转换说明则描述了如何将剩余的实参转换为字符格式显示出来.
       
         ...printf函数的这类函数的转换说明有字符%和跟随其后的最多5个不同的选项构成
       
         | %    | #0(标志) | 12(最小字段宽度) | .5(精度) | L(长度修饰符) | g(转换说明符) |
         | ---- | -------- | ---------------- | -------- | ------------- | ------------- |
       
         ```c
         //这是一个比较粗糙的实例程序
         #define _CRT_SECURE_NO_WARNINGS
         
         #include <stdio.h>
         #include <stdlib.h>
         
         int main() {
         	/*这个程序测试的是printf格式串的五个参数*/
         
         	//标记 (注意标记允许叠加)
         	printf("标记'#':  '%#x'\n",100);//标记#可以输出以0开头的8进制数,和以0X开头的16进制数.
         	printf("标记' ':  '% x'\n", 100);//以空格作为正整数的前缀.
         	printf("标记'+':  '%+d'\n", 100);//以+作为正整数的开头,但是好像只对十进制有效
         	printf("标记'0':  '%0d'\n", 100);//使用前导0作为字段填充.
         	printf("标记'-':  '%-d'\n", 100);//使用左对齐
         
         	//最小字段宽度
         	printf("最小字段宽度:  '%5d'\n", 100);
         
         	//精度
         	printf("小数-精度:  '%.3f'\n", 100.0);
         	printf("整数-精度:  '%.3d'\n", 10);
         
         	//h,l,L中的一个
         	printf("l用于整数:  '%ld'\n", 10);//表示这个一个long int类型
         	printf("l用于小数:  '%lf'\n", 10);//表示这个一个double类型
         
         	//转换说明符
         	printf("%d\n", 100);
         	printf("%f\n", 10.0);
         
         	return 0;
         }
         ```
       
         看起来有点混乱,当你仔细研究printf系列函数是才会发现他的强大,我终于明白为什么程序员一般会自己写交互函数,因为printf这种函数复杂度真的炸裂,到底会由多拖累性能我都不敢想象!
       
         和前面的惯例一样,我会添加一个小总结,设计出C语言的人明显不是一个笨蛋,不会设计一个逻辑杂乱的函数,所以有理由相信这5个参数必然有内在联系.
       
         我观察到的重点就是小数点,小数点前的是对于占位的控制,是初始化被打印的数的环境,小数点后的部分是对我们准备打印的数最后的"修改".
       
         | 标记         | 用来创建前导,比如+-号,0的填充,或者左对齐标记        |
         | ------------ | --------------------------------------------------- |
         | 最小字段宽度 | 用来规定存放数的空间的大小,但是这个不是硬性规定     |
         | .            | 这个功能的分界线                                    |
         | 精度         | 对于整数就是整数的位数,对于浮点数就是小数点后的位数 |
         | 字母         | 用来说明要打印的数的类型                            |
         | 转换说明     | 用来说明打印的数的进制                              |
       
         模板就是%lm.pth .
       
         leader(前导)minlenth(最小字段宽度).point(精度)type(用来指明是长短类型)hex(进制).
       
         .通常我们只用三个参数%m.ph.其他的好像真的没有必要记忆.
       
         ```c
         printf("%2.3d",100);//精度为3的十进制数,但是最小字段宽度为2,所以结果就是一个100 
         ```
       
         1. scanf函数调用就相当于fscanf将stdin作为第一个参数进行调用


         scanf的转换说明:
       
         | 字符*         | 赋值屏蔽,读入这个数据项但是不会赋值,不会计数                 |
         | ------------- | ------------------------------------------------------------ |
         | 最大字符宽度  | 最大字符宽度限制了输入项的字符数量,如果达到某个值,这个项目的输入就会结束,对转换开始跳过的空白字符不会统计 |
         | h,l,L中的一个 | 说明匹配的实际参数的指针类型                                 |
         | 转化说明      | 提供了一些比较智能的选项.                                    |
       
         这里会着重介绍智能匹配的转换说明符
       
         | i    | 匹配整数,可以自动录入正确格式的整数                   |
         | ---- | ----------------------------------------------------- |
         | s    | 匹配一系列非空白字符,之后在结尾添加空字符             |
         | [    | 匹配来自扫描集合的付费空字符序列,然后在末尾添加空字符 |
         | p    | 可以打印指针的值                                      |
         | %    | 匹配字符%                                             |
       
         数值型数据项可能始终使用符号+-来作为开头,而oux会自动转化为无符号数,所以通常不使用这些说明符来读取负数.
       
         说明符[是比s更加复杂的版本,完整的转换说明是%[集合]或者%`[^集合]`这里的集合可以是任何字符集(但是如果]是字符集的一个字符,那么他必须要首先出现)例如%[abc]匹配的就是只含有abc的任何字符串,而^abc匹配的是不含有abc的字符串.
       
         许多scanf类函数的转换说明符和<stdlib.h>中的字符转换函数有紧密联系,这些函数将字符串,转换为和其等价的字符型值"199"->199.(strtoul)
       
         ```c
         #include <stdio.h>
         #include <stdlib.h>
         
         int main()
         {
            char str[30] = "2030300 This is test";//准备操作的字符串
            char *ptr;//存储剩余字符串的地址的字符指针.
            long ret;//存储转换为整数的字符串
         
            ret = strtoul(str, &ptr, 10);//进行函数调用
            printf("数字（无符号长整数）是 %lu\n", ret);
            printf("字符串部分是 |%s|", ptr);
         
            return(0);
         }
         //这个函数功能有点强大,具体的效果就是,将字符串的整数部分输出,之后将剩余的字符串存储在动态内存中,之后需要一个二级指针来将修改传出程序外,这里是指针作用特点的体现:
         //"字符串"在C语言是一个动态内存,使用时都是作为一个char *类型的指针来看待,我们想要将一个字符串传出,就是要将函数外部的char *更改为我们想要存储的字符串的地址,解决办法就是将这个指针的地址传入函数,之后修改他的解引用.
         ```
       
         ```c
         //实现一个我自己的my_strtoul
         int my_strtoul(char* string, char** endptr, int radix) {
             int i; //用来遍历string的下标变量
             int i_to_letter;//用来记录字符串中的一些特殊点
             int i_to_end;//用来记录字符串的结束下标
             int stairs = 1;//用来获取指定位的数字实际代表的大小
             int digitout = 0;//这个程序的数字输出
             while (isdigit(string[i])) {
                 i++;
             }
             i_to_letter = i;
             i--;//进行数字的处理
             for (; i >= 0; i--) {
                 stairs *= radix;
                 digitout += stairs * (int)(string[i] + 0 - '0');
             }
             i = i_to_letter;
             while (string[i] != 0) {
                 i++;
             }
             i_to_end = i;
             int j = 0;
             *endptr = malloc(sizeof(char) * (i_to_end - i_to_letter + 1));
             for (i = i_to_letter; i <= i_to_end; i++) {
                 (*endptr)[j++] = string[i];
             }
             return digitout;
         
         }
         ```
    
      2. 检测文件末尾和错误条件


      ```c
      void clearerr(FILE * stream);
      int feof(FILE *stream);
      int ferror(FILE *stream);
      ```
    
       如果我们要求...scanf函数读入并且存储n个数据项目,那么希望他的返回值就是n,如果返回值小于n,那么一定发生了错误,一共有3种可能的情况.
    
      1. 文件末尾,函数在完全匹配格式串之前遇到了文件末尾
      2. 错误,错误的发生超过了函数的控制范伟
      3. 匹配失败,数据项的格式是错误的,例如函数可能在搜索整数的第一个数字期间遇到了一个字母.
    
      但是如何告知发生的是哪一种问题?在许多情况下,这都不是问题,程序出问题了,可以直接将其舍弃掉,但是想要明确失败的原因却需要花费很多时间
    
      每一个流都有和其相关的两个指示器,启动时清空.
      | 错误指示器     | 遇到错误设置错误指示器         |
      | -------------- | ------------------------------ |
      | 文件末尾指示器 | 遇到文件末尾设置文件末尾指示器 |
    
      一旦设置了错误指示器,或者文件末尾指示器,就会保持这种状态,直到可能由clearerr函数调用的引发的明确清除操作为止,clearerr函数可以清除文件末尾指示器和错误指示器.
    
      ```c
      clearerr(fp);//同时清除错误指示器,和文件末尾指示器
      ```
    
      某些其他的库函数因为副作用可以清除某种指示器,或者两种都可以清除,所以不会需要经常使用clearerr函数.

---

      虽然没有直接访问错误指示器和文件末尾指示器,但是我们可以调用feof函数和fferror函数来判断一个流的指示器,从而检测出先前出现操作失败的原因,
    
      当scanf函数的返回值小于预期值时,可以使用feof(fp)来判断一个流的指示器,如果feof返回一个非0值,说明已经到达的文件的末尾,如果ferror返回了一个非0值,说明在输入过程中发生了错误.
    
      ```c
      1. 硬件故障或介质错误：磁盘驱动器、USB 存储设备、网络存储等出现故障，或者存储介质（如硬盘、闪存）存在坏块、损坏扇区等，可能导致读取数据时出错。
      2. 文件系统错误：文件系统的元数据损坏、inode 错误、目录结构不完整等，可能使得文件无法正常访问。
      3. 权限问题：当前进程没有足够的权限打开或读取指定的文件。例如，文件权限设置为只读，而程序试图写入；或者用户无权访问某个目录下的文件。
      4. 文件不存在或已被删除：尝试读取一个不存在的文件，或者在读取过程中文件被其他程序或用户删除。
      5. 磁盘空间不足：如果在读取文件过程中需要创建临时文件或缓冲，而磁盘剩余空间不足，可能会导致读取失败。
      6. 网络问题：对于网络文件系统（如 NFS、SMB）或通过套接字模拟成文件流的情况，网络中断、超时、服务器不可达等网络问题可能导致读取失败。
      7. 缓冲区溢出：在使用 fgets、fread 等函数从文件中读取数据时，提供的缓冲区大小不足以容纳即将读取的数据，这可能导致读取失败。
      8. 流状态异常：文件流内部状态出现问题，如文件描述符无效、读取位置超出文件范围等。
      9. 系统资源限制：打开的文件描述符数量超过系统限制（ulimit），或者进程的内存使用量超过限制，可能导致无法成功打开或读取文件。
      10.程序逻辑错误：例如，对已经关闭的文件流调用读取函数，或者在文件未正确打开（如以只写模式打开）的情况下尝试读取。
      总之，ferror 返回非零值表示在输入过程中遇到了上述或其他未列出的文件相关错误。一旦遇到这种情况，应根据具体错误类型进行适当的错误处理，如输出错误信息、关闭文件流、恢复程序状态等。同时，可以结合 perror 或 strerror 函数将 errno 变量转换为可读的错误消息，以便更好地理解错误原因。
      ```


​      

   5. 小总结: 主要可以归纳为

        1. feof 表示达到了文件末尾

        2. ferror主要问题就是磁盘文件系统等造成的文件无法访问,一般不会出现这个问题,遇到这个问题可以使用perror或者strerror来结合判断.我私底下叫这三个error为error小三件.(ferror perror strerror)

        3. 如果f小两件都返回非0值(个人理解: 之所以feof或者ferror使用f开头表示这就是和文件自身合法性有关的两个函数),说明发生了匹配错误.

           ```c
           //当发生匹配错误时
           1. scanf函数会停止读取(之后直接进入返回值阶段),并且不会修改缓冲区(缓冲区和运行scanf前一样)
           2. 不会修改FILE提供的错误指示器和文件末尾指示器(个人理解: 显然FILE只需要关注文件的问题就可以了,匹配错误和文件显然无关,文件是合法的问题在于设计者的问题.)
           3. 如果不清空错误的那段缓冲区,那么缓冲区的内容都不会减少,始终保留.
           ```

           ```c
           //为了解决匹配错误有以下两种方法
           1. 如果仍然需要使用scanf进行读取就需要清空错误的那一段缓冲区
           2. 或者直接使用自定义的更加健壮的程序.
           ```

           ---

        4. 为了明白feof函数和ferror函数的用法,我们设计一个函数用来查询一个以某个整数起始的行,

           ```c
           int find_int(const char *filename,int *ptr){
           	FILE fp;
               fp=fopen(filename,"w");
               innt line =1;//确定计数行
               if(pf==NULL){
                   return -1;//表示无法打开文件
               }
               while(fscanf(fp,"%d",ptr)!=1){
                   if(ferror(fp)){
                       fclose(fp);
                       return -2;
           		}
                   if(feof(fp)){
                       fclose(fp);
                       return -3;
           		}
                   fscanf(fp,"%*[^\n]");/skip rest of line//这里相当关键,主要体现在使用了*表示只读不写还有^\n表示不包含换行的所有字符串/
                   line++;
           	}
               fclose(fp);
               return line;
           }
           ```

           ```c
           这里必须强调一点,严格的说,scanf的跳过前导空白字符串,保持读取直到最后最后一个非空字符串不是scanf的读写绝对规则.
           scanf具有多个规则,上面对于空白字符串的处理方式是默认的规则,但是实际上scanf函数会依据格式字符串来改变默认规则:
           1. 遇到%*,会将默认的读取后写入,变更为读取后丢弃
           2. 遇到[](定界符)定义字符集,保持读取直到遇到第一个不属于[]内字符集的字符为止。
           
           ```

   6. 输出函数

      ```c
      int fputc(int c,FILE *stream);
      int putc(int c,FILE *stream);
      iint putchar(int c);
      ```

      putchar向标准输出函数写入一个字符,fputc和putc是putchar向任意流写入字符的更加通用的版本,fputc通常作为函数实现,putc通常作为宏实现,putchar通常也作为宏来实现

      ```c
      #define putchar(c) putc*((c),stdout)
      ```

      既提供putc函数又提供fputc函数看起来很奇怪,宏本省具有一些问题,,虽然C程序员更加喜欢putc因为可以加快速度,但是使用fputc作为备用也是可以的.

   7. 输入函数

      ```c
      int fgetc(FILE *stream);//从任意流读入一个字符函数实现
      int getc(FILE *stream);//从任意流读入一个字符宏实现
      int getchar(FILE *stream);//从标准流读入一个字符
      int ungetc(int c,FILE *stream);//把从流读入的字符进行回退,并且清除掉流的文件末尾指示器
      
      通常情况下，ungetc 只能将一个字符推回至输入流，而且只能推回到上次未读取的位置，也就是说它不能无限次地将字符回退。
      当用于标准输入流时，ungetc 主要用于处理刚刚通过 getchar、fgetc 等函数读取的字符，因为标准输入通常是行缓冲的，一旦读取了换行符，可能已经触发了缓冲区的刷新，此时再尝试回退字符可能无效。
      ```

   8. 行的输入

      ```c
      int fputs(const char *s,FILE *stream);
      int puts(const char *s);
      ```

      将字符串中内容作为一行输出,会在打印完字符串之后添加一个换行符.

   9. 行的输入

      ```c
      char *fgets(char *s,int n,FILE *stream);
      char *gets(char *s);
      ```

      gets函数可以从标准输入读取直到换行符,并且将结果存储入s字符数组中.

      fgets函数可以从任意流中读取n个字符,遇到换行符停止读取,并且将读取的所有的内容写入到s中

      ```c
      注意: fgets 函数会读取换行符。当从文件、流或终端读取数据时，fgets 函数会读取一行文本，直到遇到换行符 \n 或者达到指定的字符数（由第二个参数决定）。换行符也会被包含在读取的字符串中，并且在换行符后面会自动添加一个空字符 \0 作为字符串的结束标记。
          但是gets函数会将字符串读入,并且将换行符转换为0存储.
      ```

   10. 块的输入输出

      ```c
      size_t fread(void *ptr,size_t size,size_t nmemb,FILE  *stream);
      size_t fwrite(void *ptr,size_t size,size_t nmemb,FILE  *stream);
      ```
    
      fread函数和fwrite函数允许程序在单步中读和写大的数据块,虽然小心使用时,可以用于文本流,但是更多用于二进制流.
    
      fwrite函数设计用来吧内存中的数组复制给流,fread将流中的数据写入数组.
    
      fwrite,fread函数可以返回写入的元素的数量(一个从数组写入流,一个从流写入数组).
    
      如果这个返回值和第三个参数不同,可以使用error三件套检查错误.

   11. 文件的定位

      ```c
      int fgetpos(FIEL *stream,fpos_t *pos);
      int fsetpos(FILE *stream,const fpos_t *pos);
      int fseek(FILE *stream,long int offset,int whence);
      long int ftell(FILE *stream);
      void rewind(FILE *stream);
      ```
    
      虽然对于许多应用程序而言,顺序访问是很好的,但是某些程序需要在文件中具有跳跃的能力.例如文件中包含一系列记录,我们希望可以条约到特殊的记录处,并且对其进行读入或者更新
    
      ```c
      fseek函数将改变首个实参(即文件指针)相关的文件位置
          
      第三个实参说明计算出的新位置是否和文件的起始处,当前位置或者文件末尾有关,stdio.h中定义了3个宏:
      SEEK_SET 文件的起始处
      SEEK_CUT 文件的当前位置
      SEEK_END 文件的末尾处.
          
      第二个实参(可能为负的)字节计数器,例如,为了移动到文件的开始处,搜索的方向将为SEEK_SET 而且字节计数器为0
      fseek(fp,0L,SEEK_SET);
      为了向文件开头方向移动10个字节,搜索的方向为SEEK_CUR
      fseek(fp,-10L,SEEK_CUR);
      ```
    
      在通常情况下,fseek函数返回0,如果产生错误(例如要求的位置不存在),那么fseek函数会返回一个非0值.
    
      文件定位函数最适用于二进制的流,C语言不静止对文本流使用这些定位函数,但是对于操作系统的差异要小心,由于这些差异,fseek函数对于文本型还是二进制的很敏感,对于文本流而言,或者
    
      1. offset,fseek的第二实参必须为0
      2. whencefseek的第三个实参必须为SEEK_SET,且通过前面的ftell函数调用获取offset的值,换句话说,我们只可以利用fseek函数移动到文件的起始处或者末尾处,或者返回前一次访问到的位置.

   11. ftell函数以长整型返回当前文案金的位置,(如果发生错误,ftell会返回-1L,并且将错误码存放到errno中)ftell可能会存储存储返回的值,并且稍后提供给fseek函数的调用.

       这也使返回前一个位置成为可能:

       ```c
       long innt file_pos;
       file_pos=ftell(fp);
       fseek(fp,file_pos,SEEK_SET);
       ```

   12. 如果fp为二进制流,那么ftell(fp)调用会以字节计数来返回当前文件的位置,其中0表示文件位置的开始,但是如果fp使文本流,ftell(fp)返回的值不一定以字节计数,结果最好不要对ftell的返回值进行算数运算,例如为了查看看两个文件位置的差距,而将ftell的返回值相减不是一个好做法.

   13. rewind函数会将文件位置设置在起始处,调用rewind函数几乎相当于fseek(fp,0L,SEEK_SET)两个的差距就是是否有返回值.

   14. 为了用于大型文件,标准C提供了两种额外的函数:即fgetpos函数和fsetpos函数,这两个函数都可以用于大型文件,因为他们都使用fpos_t型值来表示文件位置,fpos_t值不一定为整数,比如它可以为结构.

       比如fgetspos(fp,&file_pos)会将fp相关的值存储到file_pos型变量中,调用fsetpos(fp,&file_pos)会为fp设置文件的位置.并且这个位置使存在file_pos的值.如果调用失败,会将错误码存放在errno中,当调用成功时,这两个函数都会返回0.否则会返回非0值.

15. ```c
    //修改零件记录文件
    #include <stdio.h>
    #include <stdlib.h>
    
    #define NAME_LEN 25
    #define MAX_PARTS 100
    
    struct part{
    	int number;
        char name[NAME_LEN+1];
        int on_hand;
    }inventory[MAX_PARTS];
    
    int num_parts;
    
    int main(){
        FILE *fp;
        int i;
        if((fp=fopen("invent.dat","rb+"))==NULL){
            fprintf(stderr,"can't open inventory file \n");
            exit(EXIT_FAILURES);
        }
        num_parts=fread(inventory,sizeof(struct part),MAX_PARTS,fp);
        for(i=0;i<num_parts;i++){
            inventory[i].on_hand=0;
            rewind (fp);
            fwrite(inventory,sizeof(struct part),num_parts,fp);
            fclose(fp);
        }
        return 0;
    }
    ```

    这里需要着重注意的就是fread的第一个参数未必是一个字符数组,虽然我之前习惯上用字符数组来存储文件中的块文件,但是实际上这参数作为结构指针更加常见,fread很强大.

16. 字符串输入输出函数

    sprintf和sscanf函数和scanf和printf函数很相似,他们的区别是,不将数据写入流中,而是写入字符串中.

    
