1. 流

   在C语言中,**术语流意味着任意输入的源**或者任意输出的目的地.许多小程序,都是通过一个流来获得全部的输入,并且通过另一个流写出全部的输出.

   一些大型的程序需要额外的流,这些流通常表示磁盘上的文件,但是可以与其他类型的设备关联,调制解调器,网络端口,打印机,光盘驱动等等,这里集中讨论磁盘上的文件,因为这一类文件通用并且容易理解(在应该说流的时候这里可能会偶尔使用属于文件)

   但是必须要注意的一点是: stdio.h中的许多函数不仅仅可以处理表示成文件的流,还可以处理其他的所有的形式的流.

2. 文件指针

   C语言中的流通过访问文件指针实现,这个指针具有file* (在stdio.h定义了file的类型),用文件指针表示的具有特定流具有标准化的名字,如果需要,我们可以声明一些额外的文件指针,例如除了标准流,如果程序还需要两个流,那么我们可以在程序中包含下列形式的声明:
   ```c
   FILE * fp1,fp2;
   ```

   虽然操作系统通常会限制在任意的某个时刻可以打开的流的数量,但是一个程序可以声明任意数量的file *类型变量.

3. 标准流和输入重定向

   <stdio.h>提供了3中标准流:

   | 文件指针 | 流       | 默认的含义 |
   | -------- | -------- | ---------- |
   | stdin    | 标准输入 | 键盘       |
   | stdout   | 标准输出 | 屏幕       |
   | stdder   | 标准错误 | 屏幕       |

   前面使用的printf,scanf,putchar,getchar(),getc(),putc(),gets,puts.都是通过stdin输入,而且使用stdout输出,默认情况下,stdin表示键盘,二stdout和stderr表示屏幕,然而某些操作系统允许通过所谓的重定向机制来改变这些默认的含义.

   例如在UNIX和DOS操作系统中可以迫使程序从文件中而不是从键盘中获得输入,方法是在字符<后添加文件的名字,这种方法称为输出重定向

   ```c
   //理解--个人
   程序如何咋cmd环境下运行,格式就是
   程序.ext(程序自身作为参数1) 参数2 参数...
   
   向这个方面联想,因为程序必须放在第一个位置,指定的程序之后,计算机读取的后边的参数才有意义.
       
   流就像一个河流,其方向为信息流动的方向,指向程序表示信息流入程序,从程序指出到其他的地方表示将程序的信息输出.
       
   在命令行中,程序位于最左侧,所以指向程序就是小于号,表示输入从定向,指离程序就是大于号,表示输出重定向.
       
   注意在命令行中,输入输出重定向不作为程序的参数存在.
   也就是:
   程序.ext(程序自身作为参数1)  <输入.txt  >输出.txt  参数2 参数3...
   //argc=4 ...
   ```

   输入重定向的问题就是,如果程序运行失常,我们需要知道程序结束之后打开文件后才会知道,所以我们选哟将错误信息写入到stderr中,这样可以保证stdout发生重定向后错误信息仍然会出现在屏幕上.

   ```c
   fprintf(stderr,"错误信息");
   fputs("错误信息",stderr);
   puts("错误信息",stderr);
   putc('Q',stderr);
   
   stdder是一个预定义的全局变量,指向标准错误流,其变量类型为: File *,是一个指向FILE类型结构体的一个指针.
   
   //FILE 结构体封装了与特定输入输出源(如终端,磁盘文件,网络连接)交互所需要的所有信息,包括但是不限于:
    
   //1. 文件描述符,,在Unix系统中,这是一个小的非负整数,是由类型为每一个打开的文件分配的唯一标识符,通过文件标识符,程序可以与操作系统进行操交互,例如读写,关闭,等系统调用,对于标准错误流,其对应的文件描述符通常是2,标准输入0,标准输出1.
       
   //2. 缓冲区,为了提高输入输出效率,标准io通常会在内存中为每一个打开的流维护一个缓冲区,待缓冲区满了或者满足特定条件(比如遇到换行符或者手动刷新),才会将信息一次写入到实际的输出设备,标准错误通常设置为无缓冲或者行缓冲的形式,从而保证可以实时输出.
       
   //3. 缓冲区状态,包括缓冲区当前大小,已使用空间,当前位置(指针)等等信息,用于跟踪缓冲区数据状态以及何时将缓冲区的文件输出到输出流.
       
   //4. 文件位置指示器,对于可以定位的流,比如常规文件,结构体中包含一个表示当前文件读写位置的成员,对于标准错误流,由于它通常不支持随机访问,这个信息可能不是很重要.
       
   //5. 错误指示器,记录流上最近发生的IO错误状态,当发生错误时,后续的io可能会收到这个错误只是的影响.
       
   //6. EOF指示器,标记是否已经达到文件尾(EOF),对于标准错误流,这个信息通常无关紧要,因为他通常用于实时输出错误信息,而不是处理有限长度的文件.
       
   //7. 其他控制和私有标志,可能还包括一些内部使用的控制标志,以及编译器或者运行环境私有的数据,用来支持各种高级功能和特定系统接口的兼容性.我感觉还应该包含这个指针的用途,毕竟fopen函数就可以指定一个文件指针用于什么操作.后面对file*进行读写时,直接使用指针,而fopen函数已经结束.
   
   ```
   
4.  文本文件和二进制文件

   stdio.h支持两种类型的文件: 文本文件和二进制文件,在文本文件中,字节表示字符,这使人们可以检查或者编辑文件,例如C语言的源码时存放在文本文件中的,但是在二进制文件中,字节不一定是字符,字节还可以是其他类型的数据,比如整数和浮点数.

   选择二进制通常会极大的节约空间

   为什么一定要区分文本文件和二进制文件?毕竟无论哪个形式,一个文件就是一个字节的序列,文本文件按照行来划分,所以必须使用一些方法来标记每行的末尾,比如采用特殊的字符,而且操作系统可能用特殊的字符啦说明文本文件的结束,但是二进制文件可以合法的包含任何字符,所以不可能留出文件结束字符.

   ```c
   //我有一个好想法,在文本文件中我们无法写入控制字符,但是我们可以在二进制文件中写入控制字符.
   ```

   在DOS操作系统中,文本文件和二进制文件存在两个方面的差异:

   1. 行的结尾,文本文件需要特殊的标记,但是在二进制文件中不需要(回车)
   2. 文件末尾,文本文件需要特殊的标记,但是在二进制文件中不需要(ctrl +Z)
   3. 包含的特殊字符,文本文件只可以打印非控制字符,但是二进制文件可以存放一切字符,这意味着我们需要拷贝程序时,最好使用二进制,在不知道该如何处理时,最好也使用二进制.

5. 文件操作

   简单时输入输出重定向的魅力所在,他不需要打开文件,关闭文件或者执行其他明确的文件操作,但是重定向在许多程序中受到限制,当程序以来重定向时,他无法控制自己的文件,甚至无法知道这些文件的名字,更糟糕的是,如果程序需要咋同一个时间读入两个文件或者写入两个文件,重定向都无法做到

   ```c
   //所以一个支持重定向功能的程序应该具有以下特征:
   1. 错误信息使用标准错误流实时输出,而不是被重定向到生成文件中
   2. 程序只具有单个输入和单个输出
   ```

   1. 打开文件:

      ```c
      FILE * fopen(const char *filename,const char *mode);
      ```

      使用流的方式打开文件需要调用fopen函数,fopen的第一个实际参数就是要打开的文件的自负串,(需要注意的是,这个文件名可以包含关于文件位置信息,例如驱动器号或者路径)第二个实际参数就是模式,比如"r"表示打开.

      ---

      dos程序员,在遇到字符\时需要小心,因为C语言会将\看成转义序列的开始,从而导致程序无法正常运行,解决的办法就是使用\\\或者 /来替换\

      ```c
      //对于学习计算机的人而言,我们如何区分除法和转义序列?其实只需要记住其在键盘上的位置就可以了,辅助记忆: 除法左/右,其实就是分式横杠向左偏移.的产物.
      ```

      ---

      模式,打算传递给fopen的模式字符串不仅仅依赖于稍后要对文件采取的操作内容,还取决于文件上的数据是文本形式还是二进制形式.

      | 字符串     | 含义                                                   |
      | ---------- | ------------------------------------------------------ |
      | "r"(read)  | 打开的文件用于读                                       |
      | "w"(write) | 打开的文件用于写                      (文件无需存在)   |
      | "a"(add)   | 打开的文件用于追加                  (文件无需存在)     |
      | "r+"       | 打开的文件用于读和写                                   |
      | "w+"       | 打开的文件用于读和写              (如果文件存在就截去) |
      | "a+"       | 打开的文件用于读和写              (如果文件存在就追加) |

      这里需要说明,截去,指的是将文件长度截去为0,也就是从文件头开始写,后面的内容如果没有写到就不改变.

      ```c
      //小规律:
      1. 单个字母,用途就是本身    要么读要么写,
      2. 字母添加了一个+号       既可读也可写
      3. +表示补全其不具有的功能,但是原来的功能不变.
      
      比如"w+"表示的就是在w的基础上添加读取文件的能力,但是写的能力没有变,也就是如果文件存在就截断文件长度为0,从文件头开始写入,如果文件不存在就自行创建一个,从文件头写入.
      
      "r+"表示的就是在r的基础上添加写入文件的能力,但是读的能力没有改变,也就是始终从文件头开始.
      ```

      如果我们需要使用fopen打开二进制文件时,需要在模式字符串中包含字母b

      | 字符串      | 含义                                                   |
      | ----------- | ------------------------------------------------------ |
      | "rb"(read)  | 打开的文件用于读                                       |
      | "wb"(write) | 打开的文件用于写                      (文件无需存在)   |
      | "ab"(add)   | 打开的文件用于追加                  (文件无需存在)     |
      | "r+b"       | 打开的文件用于读和写                                   |
      | "w+b"       | 打开的文件用于读和写              (如果文件存在就截去) |
      | "a+b"       | 打开的文件用于读和写              (如果文件存在就追加) |
   
      stdio对写入数据和追加数据做了区分,当给文件写数据时,通常会对先前的内容进行覆写,然而当为追加文件时,试图为文件写入数据实际是在文件的末尾进行添加,二会留存原始数据的内容.
   
      顺便说一下,应用于既读又写一个已打开文件时的特殊规则(模式字符串包含+),如果没有先调用文件定位函数,那么就不可以将读转为写,而且如果既没有调用fflush函数,也没有调用文件定位函数,那么就不可以将写转换为读.
   
   2. 关闭文件
   
      ```c
      int fclose(FILE * stream);
      ```
   
      fclose函数允许程序关闭不再使用的文件,fclose函数的实际参数必须时文件指针,这个指针来自于fopen或者freopen的调用,如果成功关闭了文件,那么fclose函数会返回0,否则会返回错误代码EOF(在stdio.h中定义的宏)
   
      ```c
      #define _CRT_SECURE_NO_WARNINGS
      
      #include <stdio.h>
      #include <stdlib.h>
      
      #define FILE_NAME "example.dat"
      
      int main() {
      	FILE* fp;
      	fp = fopen(FILE_NAME, "r");
      	if (fp == NULL) {
      		fprintf(stderr, "文件无法打开\n");
      		exit(EXIT_FAILURE);
      	}
      	fclose(fp);
      	return 0;
      }
      //这里需要提示的就是,最好将指针写为fp,表示file_pointer,而不是像别人通常写的pf,point_to_file的缩写,这实际上是命名体会混乱的体现.
      
      //C语言中,只有函数应该包含动词,或者宏定义实现的"伪函数"可以用动词,其余的东西都应该使用名词,这是最通用的行业共识.
      ```
   
   3. 为流附加文件:
   
      ```c
      FILE* freopen(const char *filename,const char *mode,FILE *stream)
      ```
   
      freopen函数可以为已经打开的流附加上一个不同的文件,,freopen函数的最常见的用法就是将文件和其中的一个标准流向关联,这些标准流包括,stdin,stdout,stderr,例如,为了使程序开始向文件foo写入数据,可以使用下列形式的freopen调用:
   
      ```c
      if(freopen("foo","w",stdout)=NULL){
      /*error;foo can't be opened*/
      }
      ```
   
      在关闭了任何先前于stdout相关联的文件之后,(通过命令行重定向或者前一个freopen函数调用),freopen函数将打开文件foo,并且是这个文件和stdout相关联.
   
      freopen的返回值是他的第三个参数--文件指针,通常是自己,但是如果无法打开文件,将返回一个空指针.(如果无法关闭旧的文件,那么freopen将忽略错误.)
   
   4. ```c
      //小总结:
      stdio.h到底为文件流提供了怎样的操作呢?我大致将其分为三类:
      1. 一些预先定义好的流,比如说标准输入,标准输出,标准错误,分贝对应了FILE 结构体重的文件描述符 0,1,2
          
      2. 允许用户自己定义流的函数fopen,可以通过这个函数创建一个自定义流
          
      3. 关闭流的工具 fclose,可以用来关闭来自fopen或者freopen的指针.
          //多嘴一句: stdin,stderr,和stderr是由操作系统在程序启动时自动打开并且关联到相应的设备的特殊的流.根据C标准,对于stdin,stdout,和stderr使用fclose 的行为没有明确规定其效果,实际上,不同的编译器和平台可能对此由不同的实现和处理,一些平台会允许关闭这些流,但是后果可能包括但是不限于:引发异常,设置错误标志
          //实际测试表示,就MS的编译器而言,可以关掉!!!如何体现?
          //1. fclose 的返回值是0而不是EOF
          //2. fclose 后的scanf无法运行
          //但是没有引发十分严重的问题,额我指的是程序没有崩溃,只不过是无法输入了罢了.
          
      4. 重定向流的工具 freopen
          //这个工具的使用场景就是程序内部的重定向.日志记录,调试,还有在算法竞赛处理多个测试数据集等.
          //注意这个工具的局限性: freopen在处理任何已经打开的流,包括标准输入流,都会遵循先关闭之后重新打开的原则
          //如果希望在重定向标准输入流后让恢复原来的值,可以如此做:
      #ifdef win32
          Windows:freopn("CON","r",stdin);
      #else
      	Linux:freopen("/dev/tty","r",stdin);
      #endif
      ```
   
      合在一块说就是: 提供了一些预定义流,允许自定义流,允许自己打开或者关闭流,允许重新设置流的指向.
   
   5. 临时文件:
   
      ```c
      FILE* tmpfile(void);
      char *tmpnam(char *s);
      ```
   
      现实世界的程序经常需要产生临时文件,即只在程序运行时存在的文件,例如C语言编译器就常常产生临时文件,stdio.h提供了两种方法处理临时文件,即tmpfile函数,和tmpnam函数,这两个函数一个直接创建临时文件,一个创建一个临时文件的名字.
   
      tmpfile不需要任何参数,但是其会返回一个文件指针,这个指针指向生成的临时文件,如果临时文件产生失败,就会返回一个空指针.虽然tmpfile使用起来十分简单,但是,有两个缺点,这个文件的文件名对于用户而言是不知道的,无法决定这个临时文件是否要保留.如果我们想要了解到这些文件的名字,可以生成随机的一个名字,之后使用fopen来手动创建临时文件.
   
      而生成这个随机名称的函数就是tmpnam,如果这个函数的实参是一个空指针,那么会分配一个静态变量用来存放名字,之后将这个静态变量的地址作为返回值,如果这个函数的实参指向一个数组,必须确保这个数组具有足够的字节,否则会由内存泄露的情况出现
   
      ```c
      //demo--两种用法.
      char *tmp_name;
      tmp_name=tmpnam(NULL);
      fp=fopen(tmp_name,"w");
      free(tmp_name);
      
      
      char tmp_name[L_tmpnam];
      tmpnam(tmp_name);
      fp=fopen(tmp_name,"w");
      //这两种写法都可以.而在最后一种情况下,L_tmpnam是一个定义在stdio.h中的宏,用来指明生成的名字的最大长度.
      
      //关于这个tmpnam函数还有一些发现,实际操作,在MS编译器下,随机文件生成在temp的系统文件夹下.因为生成的文件名含有temp文件夹的完整路径.
      
      //最后依然是小总结:生成临时文件一共有两种方式,一个是直接创建文件,隐藏名字,另一种是在随机文件所在文件夹中生成一个具有随机名字的文件.
      ```
   
   6. 文件缓冲
   
      ```c
      int fflush(FILE *stream);
      void setbuf(FILE *stream,char *buf);
      int setvbuf(FILE *stream,char *buf,int type,size_t size);
      ```
   
      从磁盘驱动器或者传入信息是比较慢的操作,这样的结果是程序每次想要读或者写字 符时无法直接访问磁盘文件进行,这样的,获得有效性能的诀窍就是缓冲(buffering):写入流的数据实际存储在内存的缓冲区内,当缓冲区满了(或者关闭流)时,缓冲区会清洗(写入实际的输出设备).
   
      输入流可以使用类似的方法进行缓冲:缓冲区包含来自输入设备的数据.从缓冲区读取数据代替了从设备本身读取数据,缓冲在效率上可以取得巨大的收益,因为在缓冲区读取字符或者在缓冲区写入字符几乎不花时间,
   
      大多数时候stdio.h中的函数会自动完成缓冲操作,缓冲发生在屏幕后台,而且通常不需要考虑他的操作,但是有时我们需要承担一些更加主动的作用,如果真的如此,可以使用fflush函数,setbuf函数还有setvbuf函数.
   
      当程序向文件中写入程序时,数据通常时放在缓冲区中而不是文件内部,当缓冲区满了或者关闭文件时,缓冲区会自然清洗,然而通过调用fflush函数,程序可以像希望的那样频繁的清洗文件的缓冲区.
   
      ```c
      fflush(fp)//会清空fflush的缓冲区
      fflush(NULL)//会清空所有的输出流,如果成功会返回0,如果失败就返回EOF
      ```
   
      setvbuf函数允许改变缓冲流的方法,并且控制缓冲区的大小和位置,函数的**第三个实际参数**说明了期望的缓冲区的类型: 
   
      1. _IOFBF(满缓冲),当缓冲区为0时,从流读取数据,或者当缓冲区满时,向流写写入数据
      2. _IOLBF(行缓冲),每次从流读入一行数据或者向流写入一行数据.
      3. _IONBF(无缓冲),直接从流读入数据,或者直接向流写入数据,而没有缓冲区.
   
      setvbuf函数在第二个参数(如果不是空指针的话),是期望的缓冲区的类型,缓冲区可以有静态存储期限,自动存储期限或者可以是动态分配的,使缓冲区自动化将允许他的空间在块退出时可以被自动重声明,动态分配的缓冲区可以在不需要时自动释放,setbuf的最后一个实际参数时缓冲区中的字节的数量,较大的缓冲区可以提供更好的性能,而较小的缓冲区可以节约空间.
   
      ```c
      //小总结:
      setvbuf(FILE *stream,char *buf,int type,size_t size);
      先指明流的名称,其缓冲区的位置,缓冲区类型,缓冲区大小,还是相当符合逻辑的.
      ```
   
      如果这个函数调用成功,那么函数会返回0,否则会返回一个非0值
   
      setbuf是一个早期的函数,它用来设定缓冲区的默认值和缓冲区的大小,如果buf是空指针,那么setbuf(stream,buf)的调用你就等价于
   
      ```c
      (void) setvbuf(strean,NULL,_IONBF,0);
      ```
   
      否则的话,就等价于
   
      (void)setvbuf(stream,buf,_IOFBUF,BUFSIZ);这里的BUFSIZ是在<stdio.h>zhogn1中定义的宏我们将setbuf看作是陈旧的内容,不建议大家在新的程序中使用.
   
      ```c
      //需要注意的点:
      1. 当使用setvbuf函数或者setbuf函数时,一定要确保在释放缓冲区之前就已经关闭了流.
      2. 必须在打开stream之后,而且执行任何其他在stream上的操作之前调用setvbuf函数.
      也就是必须确保,在stream打开后,没有关闭前都要保持缓冲区的存在.千万注意释放和清空是不一样的,释放指的是取消一块内存,而不是清空这块内存上的所有内容.
      ```
   
   7. 其他文件操作:
      ```c
      int remove(const char *filename);
      int rename(const char *old,const char *new);
      ```
   
      remove 和rename可以为程序执行提供基本的文件管理工作,不同于这一节中大多数函数,这两个函数,对文件名而不是文件指针进行处理,如果调用成功,两个函数都返回0否则都返回非0值.
   
      ```c
      remove("filename");//删除文件
      rename("old name","new name");
      ```
   
      如果我们决定将文件变为永久的,那么rename是很便于对用fopen函数产生的临时文件进行换名,如果具有新的名字的文件已经存在了,那么效果将根据实现来定义.
   
      ```c
      需要注意的是,如果打开了要换名的文件,那么一定要确保在调用之前,这个文件是关闭的,否则这个文件无法被重命名.
      ```
   
      ```c
      //这是一个针对文件操作的大demo程序实例
      #define _CRT_SECURE_NO_WARNINGS
      
      #include <stdio.h>
      #include <stdlib.h>
      
      #define BUFFER_LEN 512
      
      int main() {
      	/*分析:我们的目的是通过随机名字创\
      	建一个随机文件,所以需要有名字,文件\
      	指针,还有缓冲区*/
      	char* filename;
      	FILE* fp;
      	char* buffer;
      
      	filename = tmpnam(NULL);
      	fp = fopen(filename, "w");
      	buffer = malloc(sizeof(char) * BUFFER_LEN);
      
      	setvbuf(fp, buffer, _IOFBF, BUFFER_LEN);//缓冲区设置好了.
      	fprintf(fp, "%d\n", 1887415157);
      	fprintf(fp, "%s\n", "你是螺旋升天大傻逼,真的");
      	fflush(fp);//清空我们自定义流的缓冲区
      	freopen("CON", "r", fp);//将文件流重定向到标准输入,这个过程会先关闭旧的流
      	free(buffer);//当文件流关闭后可以直接去除缓冲区.
      	
      
      	char choose;
      	printf("你想要保存程序产生的文件吗(Y/N): ");
      	fscanf(fp, "%c", &choose);
      	if (choose == 'Y' || choose == 'y') {
      		if (rename(filename, "程序生成的文件") == 0) {
      			printf("文件生成成功!\n");
      			remove(filename);//删除临时文件
      		}
      		else {
      			fprintf(stderr, "文件生成失败!\n\
      临时文件名: %s\n""请自行到指定位置查看!\n", filename);
      		}
      	}else {
      		fprintf(stderr, "你没有选择生成文件\n\
      临时文件名: %s\n""请自行到指定位置查看!\n", filename);
      	}
      
      	return 0;
      }
      //有了动态分配内存后,感觉有一点离不开他了,真的回不去了,呜呜呜~~~
      ```
      
   8. 格式化输入输出
   
      1. ...printf类函数
   
         ```c
         int fprintf(FILE *stream,const char* format,...);
         int printf(const char *format,...);
         ```
   
         fprintf和printf可以为输出流写可变的数据项,并且利用格式串来控制输出的形式,这两个函数的返回值都是以省略号结尾的,省略号说明额外的实际参数的可变数量,这两个函数的返回值是写入的字符数,如果出错就返回一个负值.
   
         printf函数的调用相当于将fprintf第一个参数设置为stdout的调用.
   
         在stdout中还有其他的两种函数也可以向流写入格式化的输出:
   
         vfprintf,vprintf.这两个函数将在后面的stdarg中提到.
   
      2. ...printf类函数的转换说明.
   
         fprintf函数和printf函数都要求格式串包含普通字符或者转换说明,普通字符会原样输出,而转换说明则描述了如何将剩余的实参转换为字符格式显示出来.
         
         ...printf函数的这类函数的转换说明有字符%和跟随其后的最多5个不同的选项构成
         
         | %    | #0(标志) | 12(最小字段宽度) | .5(精度) | L(长度修饰符) | g(转换说明符) |
         | ---- | -------- | ---------------- | -------- | ------------- | ------------- |
         
         ```c
         //这是一个比较粗糙的实例程序
         #define _CRT_SECURE_NO_WARNINGS
         
         #include <stdio.h>
         #include <stdlib.h>
         
         int main() {
         	/*这个程序测试的是printf格式串的五个参数*/
         
         	//标记 (注意标记允许叠加)
         	printf("标记'#':  '%#x'\n",100);//标记#可以输出以0开头的8进制数,和以0X开头的16进制数.
         	printf("标记' ':  '% x'\n", 100);//以空格作为正整数的前缀.
         	printf("标记'+':  '%+d'\n", 100);//以+作为正整数的开头,但是好像只对十进制有效
         	printf("标记'0':  '%0d'\n", 100);//使用前导0作为字段填充.
         	printf("标记'-':  '%-d'\n", 100);//使用左对齐
         
         	//最小字段宽度
         	printf("最小字段宽度:  '%5d'\n", 100);
         
         	//精度
         	printf("小数-精度:  '%.3f'\n", 100.0);
         	printf("整数-精度:  '%.3d'\n", 10);
         
         	//h,l,L中的一个
         	printf("l用于整数:  '%ld'\n", 10);//表示这个一个long int类型
         	printf("l用于小数:  '%lf'\n", 10);//表示这个一个double类型
         
         	//转换说明符
         	printf("%d\n", 100);
         	printf("%f\n", 10.0);
         
         	return 0;
         }
         ```
         
         看起来有点混乱,当你仔细研究printf系列函数是才会发现他的强大,我终于明白为什么程序员一般会自己写交互函数,因为printf这种函数复杂度真的炸裂,到底会由多拖累性能我都不敢想象!
         
         和前面的惯例一样,我会添加一个小总结,设计出C语言的人明显不是一个笨蛋,不会设计一个逻辑杂乱的函数,所以有理由相信这5个参数必然有内在联系.
         
         我观察到的重点就是小数点,小数点前的是对于占位的控制,是初始化被打印的数的环境,小数点后的部分是对我们准备打印的数最后的"修改".
         
         | 标记         | 用来创建前导,比如+-号,0的填充,或者左对齐标记        |
         | ------------ | --------------------------------------------------- |
         | 最小字段宽度 | 用来规定存放数的空间的大小,但是这个不是硬性规定     |
         | .            | 这个功能的分界线                                    |
         | 精度         | 对于整数就是整数的位数,对于浮点数就是小数点后的位数 |
         | 字母         | 用来说明要打印的数的类型                            |
         | 转换说明     | 用来说明打印的数的进制                              |
         
         模板就是%lm.pth .
         
         leader(前导)minlenth(最小字段宽度).point(精度)type(用来指明是长短类型)hex(进制).
         
         .通常我们只用三个参数%m.ph.其他的好像真的没有必要记忆.
         
         ```c
         printf("%2.3d",100);//精度为3的十进制数,但是最小字段宽度为2,所以结果就是一个100 
         ```
         
         
