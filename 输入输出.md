1. 流

   在C语言中,**术语流意味着任意输入的源**或者任意输出的目的地.许多小程序,都是通过一个流来获得全部的输入,并且通过另一个流写出全部的输出.

   一些大型的程序需要额外的流,这些流通常表示磁盘上的文件,但是可以与其他类型的设备关联,调制解调器,网络端口,打印机,光盘驱动等等,这里集中讨论磁盘上的文件,因为这一类文件通用并且容易理解(在应该说流的时候这里可能会偶尔使用属于文件)

   但是必须要注意的一点是: stdio.h中的许多函数不仅仅可以处理表示成文件的流,还可以处理其他的所有的形式的流.

2. 文件指针

   C语言中的流通过访问文件指针实现,这个指针具有file* (在stdio.h定义了file的类型),用文件指针表示的具有特定流具有标准化的名字,如果需要,我们可以声明一些额外的文件指针,例如除了标准流,如果程序还需要两个流,那么我们可以在程序中包含下列形式的声明:
   ```c
   FILE * fp1,fp2;
   ```

   虽然操作系统通常会限制在任意的某个时刻可以打开的流的数量,但是一个程序可以声明任意数量的file *类型变量.

3. 标准流和输入重定向

   <stdio.h>提供了3中标准流:

   | 文件指针 | 流       | 默认的含义 |
   | -------- | -------- | ---------- |
   | stdin    | 标准输入 | 键盘       |
   | stdout   | 标准输出 | 屏幕       |
   | stdder   | 标准错误 | 屏幕       |

   前面使用的printf,scanf,putchar,getchar(),getc(),putc(),gets,puts.都是通过stdin输入,而且使用stdout输出,默认情况下,stdin表示键盘,二stdout和stderr表示屏幕,然而某些操作系统允许通过所谓的重定向机制来改变这些默认的含义.

   例如在UNIX和DOS操作系统中可以迫使程序从文件中而不是从键盘中获得输入,方法是在字符<后添加文件的名字,这种方法称为输出重定向

   ```c
   //理解--个人
   程序如何咋cmd环境下运行,格式就是
   程序.ext(程序自身作为参数1) 参数2 参数...
   
   向这个方面联想,因为程序必须放在第一个位置,指定的程序之后,计算机读取的后边的参数才有意义.
       
   流就像一个河流,其方向为信息流动的方向,指向程序表示信息流入程序,从程序指出到其他的地方表示将程序的信息输出.
       
   在命令行中,程序位于最左侧,所以指向程序就是小于号,表示输入从定向,指离程序就是大于号,表示输出重定向.
       
   注意在命令行中,输入输出重定向不作为程序的参数存在.
   也就是:
   程序.ext(程序自身作为参数1)  <输入.txt  >输出.txt  参数2 参数3...
   //argc=4 ...
   ```

   输入重定向的问题就是,如果程序运行失常,我们需要知道程序结束之后打开文件后才会知道,所以我们选哟将错误信息写入到stderr中,这样可以保证stdout发生重定向后错误信息仍然会出现在屏幕上.

   ```c
   fprintf(stderr,"错误信息");
   fputs("错误信息",stderr);
   puts("错误信息",stderr);
   putc('Q',stderr);
   
   stdder是一个预定义的全局变量,指向标准错误流,其变量类型为: File *,是一个指向FILE类型结构体的一个指针.
   
   //FILE 结构体封装了与特定输入输出源(如终端,磁盘文件,网络连接)交互所需要的所有信息,包括但是不限于:
    
   //1. 文件描述符,,在Unix系统中,这是一个小的非负整数,是由类型为每一个打开的文件分配的唯一标识符,通过文件标识符,程序可以与操作系统进行操交互,例如读写,关闭,等系统调用,对于标准错误流,其对应的文件描述符通常是2,标准输入0,标准输出1.
       
   //2. 缓冲区,为了提高输入输出效率,标准io通常会在内存中为每一个打开的流维护一个缓冲区,待缓冲区满了或者满足特定条件(比如遇到换行符或者手动刷新),才会将信息一次写入到实际的输出设备,标准错误通常设置为无缓冲或者行缓冲的形式,从而保证可以实时输出.
       
   //3. 缓冲区状态,包括缓冲区当前大小,已使用空间,当前位置(指针)等等信息,用于跟踪缓冲区数据状态以及何时将缓冲区的文件输出到输出流.
       
   //4. 文件位置指示器,对于可以定位的流,比如常规文件,结构体中包含一个表示当前文件读写位置的成员,对于标准错误流,由于它通常不支持随机访问,这个信息可能不是很重要.
       
   //5. 错误指示器,记录流上最近发生的IO错误状态,当发生错误时,后续的io可能会收到这个错误只是的影响.
       
   //6. EOF指示器,标记是否已经达到文件尾(EOF),对于标准错误流,这个信息通常无关紧要,因为他通常用于实时输出错误信息,而不是处理有限长度的文件.
       
   //7. 其他控制和私有标志
   可能还包括一些内部使用的孔子标志,以及编译器或者运行环境私有的数据,用来支持各种高级功能和特定系统接口的兼容性.
   
   ```

   





