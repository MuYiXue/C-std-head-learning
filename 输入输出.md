1. 流

   在C语言中,**术语流意味着任意输入的源**或者任意输出的目的地.许多小程序,都是通过一个流来获得全部的输入,并且通过另一个流写出全部的输出.

   一些大型的程序需要额外的流,这些流通常表示磁盘上的文件,但是可以与其他类型的设备关联,调制解调器,网络端口,打印机,光盘驱动等等,这里集中讨论磁盘上的文件,因为这一类文件通用并且容易理解(在应该说流的时候这里可能会偶尔使用属于文件)

   但是必须要注意的一点是: stdio.h中的许多函数不仅仅可以处理表示成文件的流,还可以处理其他的所有的形式的流.

2. 文件指针

   C语言中的流通过访问文件指针实现,这个指针具有file* (在stdio.h定义了file的类型),用文件指针表示的具有特定流具有标准化的名字,如果需要,我们可以声明一些额外的文件指针,例如除了标准流,如果程序还需要两个流,那么我们可以在程序中包含下列形式的声明:
   ```c
   FILE * fp1,fp2;
   ```

   虽然操作系统通常会限制在任意的某个时刻可以打开的流的数量,但是一个程序可以声明任意数量的file *类型变量.

3. 标准流和输入重定向

   <stdio.h>提供了3中标准流:

   | 文件指针 | 流       | 默认的含义 |
   | -------- | -------- | ---------- |
   | stdin    | 标准输入 | 键盘       |
   | stdout   | 标准输出 | 屏幕       |
   | stdder   | 标准错误 | 屏幕       |

   前面使用的printf,scanf,putchar,getchar(),getc(),putc(),gets,puts.都是通过stdin输入,而且使用stdout输出,默认情况下,stdin表示键盘,二stdout和stderr表示屏幕,然而某些操作系统允许通过所谓的重定向机制来改变这些默认的含义.

   例如在UNIX和DOS操作系统中可以迫使程序从文件中而不是从键盘中获得输入,方法是在字符<后添加文件的名字,这种方法称为输出重定向

   ```c
   //理解--个人
   程序如何咋cmd环境下运行,格式就是
   程序.ext(程序自身作为参数1) 参数2 参数...
   
   向这个方面联想,因为程序必须放在第一个位置,指定的程序之后,计算机读取的后边的参数才有意义.
       
   流就像一个河流,其方向为信息流动的方向,指向程序表示信息流入程序,从程序指出到其他的地方表示将程序的信息输出.
       
   在命令行中,程序位于最左侧,所以指向程序就是小于号,表示输入从定向,指离程序就是大于号,表示输出重定向.
       
   注意在命令行中,输入输出重定向不作为程序的参数存在.
   也就是:
   程序.ext(程序自身作为参数1)  <输入.txt  >输出.txt  参数2 参数3...
   //argc=4 ...
   ```

   输入重定向的问题就是,如果程序运行失常,我们需要知道程序结束之后打开文件后才会知道,所以我们选哟将错误信息写入到stderr中,这样可以保证stdout发生重定向后错误信息仍然会出现在屏幕上.

   ```c
   fprintf(stderr,"错误信息");
   fputs("错误信息",stderr);
   puts("错误信息",stderr);
   putc('Q',stderr);
   
   stdder是一个预定义的全局变量,指向标准错误流,其变量类型为: File *,是一个指向FILE类型结构体的一个指针.
   
   //FILE 结构体封装了与特定输入输出源(如终端,磁盘文件,网络连接)交互所需要的所有信息,包括但是不限于:
    
   //1. 文件描述符,,在Unix系统中,这是一个小的非负整数,是由类型为每一个打开的文件分配的唯一标识符,通过文件标识符,程序可以与操作系统进行操交互,例如读写,关闭,等系统调用,对于标准错误流,其对应的文件描述符通常是2,标准输入0,标准输出1.
       
   //2. 缓冲区,为了提高输入输出效率,标准io通常会在内存中为每一个打开的流维护一个缓冲区,待缓冲区满了或者满足特定条件(比如遇到换行符或者手动刷新),才会将信息一次写入到实际的输出设备,标准错误通常设置为无缓冲或者行缓冲的形式,从而保证可以实时输出.
       
   //3. 缓冲区状态,包括缓冲区当前大小,已使用空间,当前位置(指针)等等信息,用于跟踪缓冲区数据状态以及何时将缓冲区的文件输出到输出流.
       
   //4. 文件位置指示器,对于可以定位的流,比如常规文件,结构体中包含一个表示当前文件读写位置的成员,对于标准错误流,由于它通常不支持随机访问,这个信息可能不是很重要.
       
   //5. 错误指示器,记录流上最近发生的IO错误状态,当发生错误时,后续的io可能会收到这个错误只是的影响.
       
   //6. EOF指示器,标记是否已经达到文件尾(EOF),对于标准错误流,这个信息通常无关紧要,因为他通常用于实时输出错误信息,而不是处理有限长度的文件.
       
   //7. 其他控制和私有标志,可能还包括一些内部使用的控制标志,以及编译器或者运行环境私有的数据,用来支持各种高级功能和特定系统接口的兼容性.我感觉还应该包含这个指针的用途,毕竟fopen函数就可以指定一个文件指针用于什么操作.后面对file*进行读写时,直接使用指针,而fopen函数已经结束.
   
   ```
   

4.  文本文件和二进制文件

   stdio.h支持两种类型的文件: 文本文件和二进制文件,在文本文件中,字节表示字符,这使人们可以检查或者编辑文件,例如C语言的源码时存放在文本文件中的,但是在二进制文件中,字节不一定是字符,字节还可以是其他类型的数据,比如整数和浮点数.

   选择二进制通常会极大的节约空间

   为什么一定要区分文本文件和二进制文件?毕竟无论哪个形式,一个文件就是一个字节的序列,文本文件按照行来划分,所以必须使用一些方法来标记每行的末尾,比如采用特殊的字符,而且操作系统可能用特殊的字符啦说明文本文件的结束,但是二进制文件可以合法的包含任何字符,所以不可能留出文件结束字符.

   ```c
   //我有一个好想法,在文本文件中我们无法写入控制字符,但是我们可以在二进制文件中写入控制字符.
   ```

   在DOS操作系统中,文本文件和二进制文件存在两个方面的差异:

   1. 行的结尾,文本文件需要特殊的标记,但是在二进制文件中不需要(回车)
   2. 文件末尾,文本文件需要特殊的标记,但是在二进制文件中不需要(ctrl +Z)
   3. 包含的特殊字符,文本文件只可以打印非控制字符,但是二进制文件可以存放一切字符,这意味着我们需要拷贝程序时,最好使用二进制,在不知道该如何处理时,最好也使用二进制.

5. 文件操作

   简单时输入输出重定向的魅力所在,他不需要打开文件,关闭文件或者执行其他明确的文件操作,但是重定向在许多程序中受到限制,当程序以来重定向时,他无法控制自己的文件,甚至无法知道这些文件的名字,更糟糕的是,如果程序需要咋同一个时间读入两个文件或者写入两个文件,重定向都无法做到

   ```c
   //所以一个支持重定向功能的程序应该具有以下特征:
   1. 错误信息使用标准错误流实时输出,而不是被重定向到生成文件中
   2. 程序只具有单个输入和单个输出
   ```

   1. 打开文件:

      ```c
      FILE * fopen(const char *filename,const char *mode);
      ```

      使用流的方式打开文件需要调用fopen函数,fopen的第一个实际参数就是要打开的文件的自负串,(需要注意的是,这个文件名可以包含关于文件位置信息,例如驱动器号或者路径)第二个实际参数就是模式,比如"r"表示打开.

      ---

      dos程序员,在遇到字符\时需要小心,因为C语言会将\看成转义序列的开始,从而导致程序无法正常运行,解决的办法就是使用\\\或者 /来替换\

      ```c
      //对于学习计算机的人而言,我们如何区分除法和转义序列?其实只需要记住其在键盘上的位置就可以了,辅助记忆: 除法左/右,其实就是分式横杠向左偏移.的产物.
      ```

      ---

      模式,打算传递给fopen的模式字符串不仅仅依赖于稍后要对文件采取的操作内容,还取决于文件上的数据是文本形式还是二进制形式.

      | 字符串     | 含义                                                   |
      | ---------- | ------------------------------------------------------ |
      | "r"(read)  | 打开的文件用于读                                       |
      | "w"(write) | 打开的文件用于写                      (文件无需存在)   |
      | "a"(add)   | 打开的文件用于追加                  (文件无需存在)     |
      | "r+"       | 打开的文件用于读和写                                   |
      | "w+"       | 打开的文件用于读和写              (如果文件存在就截去) |
      | "a+"       | 打开的文件用于读和写              (如果文件存在就追加) |

      这里需要说明,截去,指的是将文件长度截去为0,也就是从文件头开始写,后面的内容如果没有写到就不改变.

      ```c
      //小规律:
      1. 单个字母,用途就是本身    要么读要么写,
      2. 字母添加了一个+号       既可读也可写
      3. +表示补全其不具有的功能,但是原来的功能不变.
      
      比如"w+"表示的就是在w的基础上添加读取文件的能力,但是写的能力没有变,也就是如果文件存在就截断文件长度为0,从文件头开始写入,如果文件不存在就自行创建一个,从文件头写入.
      
      "r+"表示的就是在r的基础上添加写入文件的能力,但是读的能力没有改变,也就是始终从文件头开始.
      ```

      

      
